<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Campus Guide - Navegue pelo Campus</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            display: flex;
            background: #f0f2f5;
        }

        /* Mapa Interativo */
        #map-container {
            flex: 1;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        /* Painel do Chat */
        #chat-panel {
            width: 400px;
            background: white;
            display: flex;
            flex-direction: column;
            border-left: 2px solid #ddd;
        }

        #chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        #chat-header h2 {
            margin-bottom: 5px;
        }

        #chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .message {
            padding: 12px 16px;
            border-radius: 18px;
            max-width: 80%;
            word-wrap: break-word;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            background: #667eea;
            color: white;
            align-self: flex-end;
            margin-left: auto;
        }

        .message.bot {
            background: #f0f2f5;
            color: #333;
            align-self: flex-start;
        }

        #chat-input-container {
            padding: 20px;
            background: white;
            border-top: 1px solid #ddd;
        }

        #chat-input-form {
            display: flex;
            gap: 10px;
        }

        #chat-input {
            flex: 1;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 25px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.3s;
        }

        #chat-input:focus {
            border-color: #667eea;
        }

        #send-button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
        }

        #send-button:hover {
            transform: scale(1.05);
        }

        #send-button:active {
            transform: scale(0.95);
        }

        /* Controles do Mapa */
        .map-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-width: 320px;
        }
        
        .nav-predio-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            min-width: 280px;
        }
        
        .nav-predio-controls h3 {
            margin: 0 0 15px 0;
            color: #667eea;
            font-size: 16px;
        }
        
        .nav-group {
            margin-bottom: 15px;
        }
        
        .nav-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #666;
            font-weight: 600;
        }
        
        .nav-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.3s;
        }
        
        .nav-group select:focus {
            border-color: #667eea;
        }
        
        .btn-calcular-rota {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .btn-calcular-rota:hover {
            transform: translateY(-2px);
        }
        
        .btn-limpar-rota {
            width: 100%;
            padding: 10px;
            background: #f0f2f5;
            color: #666;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
        }
        
        .rota-info {
            margin-top: 15px;
            padding: 15px;
            background: #f0f2f5;
            border-radius: 8px;
            font-size: 13px;
            display: none;
        }
        
        .rota-info.visible {
            display: block;
        }
        
        .rota-info h4 {
            margin: 0 0 10px 0;
            color: #667eea;
            font-size: 14px;
        }
        
        .rota-info p {
            margin: 5px 0;
            color: #333;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .map-controls select {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        .map-controls select:focus {
            border-color: #667eea;
            outline: none;
        }

        .btn-tracar-rota {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
            transition: transform 0.2s;
        }

        .btn-tracar-rota:hover {
            transform: translateY(-2px);
        }

        .btn-tracar-rota:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-limpar-rota {
            width: 100%;
            padding: 8px;
            background: #f0f2f5;
            color: #666;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 8px;
            transition: all 0.2s;
        }

        .btn-limpar-rota:hover {
            background: #e4e6eb;
        }

        /* Marcador de Local */
        .location-marker {
            background: #667eea;
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            white-space: nowrap;
        }

        .location-marker.origin {
            background: #28a745;
        }

        .location-marker.destination {
            background: #dc3545;
        }
        
        /* Bot√£o para voltar ao mapa geral */
        .btn-voltar-mapa {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
            padding: 12px 20px;
            background: white;
            border: 2px solid #667eea;
            border-radius: 25px;
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.3s;
            display: none;
        }
        
        .btn-voltar-mapa:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
        }
        
        .btn-voltar-mapa.visible {
            display: block;
        }

        /* Responsivo Mobile */
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            #map-container {
                height: 50%;
            }

            #chat-panel {
                width: 100%;
                height: 50%;
            }
        }
    </style>
</head>
<body>
    <!-- Mapa Interativo -->
    <div id="map-container">
        <div class="nav-predio-controls">
            <h3>üìç Informa√ß√µes da Rota</h3>
            
            <div id="rota-info" class="rota-info" style="display: block;">
                <p id="rota-origem-destino" style="font-weight: bold; color: #667eea; margin-bottom: 10px; font-size: 14px;"></p>
                <p id="rota-distancia" style="font-size: 15px;"></p>
                <p id="rota-tempo" style="font-size: 15px;"></p>
            </div>
            
            <button id="limpar-rota-predios" class="btn-limpar-rota">
                üóëÔ∏è Limpar Rota
            </button>
            
            <!-- Campos hidden para compatibilidade com o c√≥digo -->
            <select id="predio-origem" style="display: none;"></select>
            <select id="predio-destino" style="display: none;"></select>
        </div>
        
        <button id="voltar-mapa-btn" class="btn-voltar-mapa">
            üó∫Ô∏è Voltar ao Mapa Geral
        </button>
        
        <div id="map"></div>
    </div>

    <!-- Painel do Chat -->
    <div id="chat-panel">
        <div id="chat-header">
            <h2>Campus Guide</h2>
            <p>Seu assistente de navega√ß√£o</p>
        </div>
        <div id="chat-messages">
            <div class="message bot">
                Ol√°! Sou o assistente do Campus Guide. Como posso te ajudar a encontrar um local no campus?
            </div>
        </div>
        <div id="chat-input-container">
            <form id="chat-input-form">
                <input 
                    type="text" 
                    id="chat-input" 
                    placeholder="Pergunte algo... Ex: Onde fica a sala 101?"
                    autocomplete="off"
                >
                <button type="submit" id="send-button">Enviar</button>
            </form>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Configura√ß√£o da API
        const API_URL = 'http://localhost:8000';

        // Estado da aplica√ß√£o
        let mapaAtual = null;
        let marcadores = [];
        let prediosData = [];
        let linhaRota = null;
        let marcadoresRota = [];
        let geojsonLayer = null;
        let svgOverlay = null;
        let modoPlantaInterna = false;

        // Inicializar mapa Leaflet com coordenadas geogr√°ficas (como Google Maps)
        const map = L.map('map', {
            center: [43.0125, -81.2002],  // Centro da Fanshawe College
            zoom: 16,
            minZoom: 14,
            maxZoom: 20
        });

        // Adicionar camada de tiles (mapa base estilo Google Maps)
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            maxZoom: 20
        }).addTo(map);

        // Carregar GeoJSON dos pr√©dios
        async function carregarGeoJSON() {
            try {
                const response = await fetch(`${API_URL}/api/geojson`);
                const geojson = await response.json();
                
                // Renderizar GeoJSON no mapa (pr√©dios da universidade)
                geojsonLayer = L.geoJSON(geojson, {
                    style: (feature) => {
                        // Estilo diferenciado por tipo de pr√©dio
                        const isCollege = feature.properties.building === 'college';
                        return {
                            color: isCollege ? '#667eea' : '#95a5a6',
                            weight: isCollege ? 3 : 2,
                            fillOpacity: isCollege ? 0.3 : 0.1,
                            fillColor: isCollege ? '#764ba2' : '#bdc3c7'
                        };
                    },
                    onEachFeature: (feature, layer) => {
                        const props = feature.properties;
                        const nome = props.name || props.nome || 'Edif√≠cio sem nome';
                        const ref = props.ref ? ` (${props.ref})` : '';
                        const tipo = props.building || 'Edif√≠cio';
                        
                        // Popup com informa√ß√µes
                        layer.bindPopup(`
                            <div style="min-width: 200px">
                                <strong style="font-size: 16px; color: #667eea">${nome}${ref}</strong><br>
                                <span style="color: #666; font-size: 12px">Tipo: ${tipo}</span><br>
                                ${props['building:levels'] ? `<span style="color: #666; font-size: 12px">Andares: ${props['building:levels']}</span><br>` : ''}
                                ${props.descricao ? `<p style="margin: 8px 0; font-size: 13px">${props.descricao}</p>` : ''}
                                <button onclick="verDetalhesPredi('${props.predio_id || nome}')" 
                                        style="margin-top: 8px; padding: 6px 12px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer">
                                    Ver Planta Interna
                                </button>
                            </div>
                        `);
                        
                        // Destaque ao passar o mouse
                        layer.on('mouseover', function() {
                            this.setStyle({
                                weight: 5,
                                fillOpacity: 0.5
                            });
                        });
                        
                        layer.on('mouseout', function() {
                            geojsonLayer.resetStyle(this);
                        });
                    }
                }).addTo(map);
                
                // Ajusta a visualiza√ß√£o para mostrar todos os pr√©dios da universidade
                if (geojson.features.length > 0) {
                    map.fitBounds(geojsonLayer.getBounds(), { padding: [50, 50] });
                }
                
            } catch (error) {
                console.error('Erro ao carregar GeoJSON:', error);
            }
        }

        // Carregar dados dos pr√©dios (DESABILITADO - n√£o usado mais)
        async function carregarPredios() {
            // Fun√ß√£o antiga removida - agora usamos carregarPrediosDisponiveis()
            return;
            /*
            try {
                const response = await fetch(`${API_URL}/api/predios`);
                const data = await response.json();
                prediosData = data.predios;
                
                const select = document.getElementById('predio-select');
                select.innerHTML = '<option value="">Selecione um pr√©dio</option>';
                
                prediosData.forEach(predio => {
                    const option = document.createElement('option');
                    option.value = predio.id;
                    option.textContent = predio.nome;
                    select.appendChild(option);
                });

                // Carregar primeiro pr√©dio automaticamente
                if (prediosData.length > 0) {
                    select.value = prediosData[0].id;
                    carregarMapaPredio(prediosData[0].id);
                }
            } catch (error) {
                console.error('Erro ao carregar pr√©dios:', error);
                adicionarMensagemBot('‚ö†Ô∏è Erro ao conectar com o servidor. Verifique se o backend est√° rodando.');
            }
            */
        }

        // Fun√ß√£o global para ver detalhes do pr√©dio
        window.verDetalhesPredi = function(predioId) {
            carregarMapaPredio(predioId);
        };
        
        // Carregar mapa de um pr√©dio espec√≠fico (planta interna)
        async function carregarMapaPredio(predioId) {
            try {
                const response = await fetch(`${API_URL}/api/predios/${predioId}`);
                if (!response.ok) {
                    adicionarMensagemBot('‚ö†Ô∏è Planta interna ainda n√£o dispon√≠vel para este pr√©dio.');
                    return;
                }
                
                const predio = await response.json();
                
                // Limpar marcadores antigos
                marcadores.forEach(m => map.removeLayer(m));
                marcadores = [];

                // Remover camada de imagem antiga
                if (mapaAtual) {
                    map.removeLayer(mapaAtual);
                }
                
                // Remover SVG overlay antigo
                if (svgOverlay) {
                    map.removeLayer(svgOverlay);
                    svgOverlay = null;
                }

                // Encontrar o pr√©dio no GeoJSON para pegar as coordenadas geogr√°ficas
                let predioGeoJSON = null;
                if (geojsonLayer) {
                    geojsonLayer.eachLayer((layer) => {
                        const props = layer.feature.properties;
                        if (props.predio_id === predioId || props.name === predioId) {
                            predioGeoJSON = layer;
                        }
                    });
                }
                
                // Se encontrou o pr√©dio, usar seus bounds geogr√°ficos
                if (predioGeoJSON) {
                    const bounds = predioGeoJSON.getBounds();
                    
                    // Adicionar imagem do mapa sobreposta ao pr√©dio
                    mapaAtual = L.imageOverlay(
                        `${API_URL}${predio.imagem_url}`,
                        bounds,
                        { opacity: 0.8 }
                    ).addTo(map);

                    map.fitBounds(bounds, { padding: [50, 50] });
                    
                    // Ativar modo planta interna
                    modoPlantaInterna = true;
                    document.getElementById('voltar-mapa-btn').classList.add('visible');
                    
                    adicionarMensagemBot(`üìç Mostrando planta interna: ${predio.nome}`);
                    
                    // Carregar SVG overlay se dispon√≠vel
                    if (predio.svg_url) {
                        carregarSVGOverlay(predio.svg_url, bounds);
                    }

                    // Adicionar marcadores dos locais usando coordenadas geogr√°ficas
                    predio.locais.forEach(local => {
                        // Converter coordenadas pixel para lat/lng
                        const latLng = pixelParaLatLng(
                            local.coordenadas.x, 
                            local.coordenadas.y,
                            predio.dimensoes,
                            bounds
                        );
                        
                        const marker = L.marker(latLng, {
                            icon: L.divIcon({
                                className: 'location-marker',
                                html: local.nome
                            })
                        }).addTo(map);

                        marker.bindPopup(`
                            <strong>${local.nome}</strong><br>
                            ${local.descricao || ''}
                        `);

                        marcadores.push(marker);
                    });

                    // Atualizar seletores de origem e destino
                    atualizarSeletoresLocais(predioId, predio.locais);
                } else {
                    adicionarMensagemBot('‚ö†Ô∏è N√£o foi poss√≠vel localizar este pr√©dio no mapa.');
                }

            } catch (error) {
                console.error('Erro ao carregar mapa:', error);
                adicionarMensagemBot('Erro ao carregar planta interna do pr√©dio.');
            }
        }
        
        // Converter coordenadas pixel para lat/lng
        function pixelParaLatLng(pixelX, pixelY, dimensoes, bounds) {
            // Normalizar coordenadas (0-1)
            const normX = pixelX / dimensoes.largura;
            const normY = pixelY / dimensoes.altura;
            
            // Interpolar entre os bounds geogr√°ficos
            const latMin = bounds.getSouth();
            const latMax = bounds.getNorth();
            const lngMin = bounds.getWest();
            const lngMax = bounds.getEast();
            
            // Y √© invertido (pixel Y cresce para baixo, lat cresce para cima)
            const lat = latMax - (normY * (latMax - latMin));
            const lng = lngMin + (normX * (lngMax - lngMin));
            
            return [lat, lng];
        }
        
        // Carregar SVG overlay sobre a imagem
        async function carregarSVGOverlay(svgUrl, bounds) {
            try {
                const response = await fetch(`${API_URL}${svgUrl}`);
                const svgText = await response.text();
                
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
                const svgElement = svgDoc.documentElement;
                
                // Criar overlay SVG
                svgOverlay = L.svgOverlay(svgElement, bounds, {
                    interactive: true,
                    opacity: 0.7
                }).addTo(map);
                
                // Adicionar interatividade aos elementos do SVG
                adicionarInteratividadeSVG(svgElement);
                
            } catch (error) {
                console.error('Erro ao carregar SVG overlay:', error);
            }
        }
        
        // Adicionar eventos de clique aos elementos do SVG
        function adicionarInteratividadeSVG(svgElement) {
            // Tornar salas clic√°veis
            const salas = svgElement.querySelectorAll('[id^="sala_"], [class*="room"]');
            salas.forEach(sala => {
                sala.style.cursor = 'pointer';
                sala.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const salaId = sala.id || sala.getAttribute('class');
                    adicionarMensagemBot(`Voc√™ clicou em: ${salaId}`);
                    
                    // Destacar a sala
                    sala.style.fill = '#667eea';
                    sala.style.fillOpacity = '0.3';
                    
                    setTimeout(() => {
                        sala.style.fill = '';
                        sala.style.fillOpacity = '';
                    }, 2000);
                });
                
                sala.addEventListener('mouseenter', () => {
                    sala.style.strokeWidth = '4';
                    sala.style.stroke = '#667eea';
                });
                
                sala.addEventListener('mouseleave', () => {
                    sala.style.strokeWidth = '';
                    sala.style.stroke = '';
                });
            });
        }

        // Atualizar seletores de origem e destino
        function atualizarSeletoresLocais(predioId, locais) {
            const selectOrigem = document.getElementById('origem-select');
            const selectDestino = document.getElementById('destino-select');
            
            selectOrigem.innerHTML = '<option value="">Selecione um local</option>';
            selectDestino.innerHTML = '<option value="">Selecione um local</option>';
            
            locais.forEach(local => {
                const option1 = document.createElement('option');
                option1.value = JSON.stringify({
                    predio_id: predioId,
                    local_id: local.id,
                    coordenadas: local.coordenadas
                });
                option1.textContent = local.nome;
                selectOrigem.appendChild(option1);
                
                const option2 = document.createElement('option');
                option2.value = JSON.stringify({
                    predio_id: predioId,
                    local_id: local.id,
                    coordenadas: local.coordenadas
                });
                option2.textContent = local.nome;
                selectDestino.appendChild(option2);
            });
        }

        // Event listeners antigos removidos - c√≥digo migrado para navega√ß√£o entre pr√©dios
        
        // Voltar ao mapa geral
        document.getElementById('voltar-mapa-btn').addEventListener('click', () => {
            voltarMapaGeral();
        });
        
        function voltarMapaGeral() {
            // Limpar overlays de planta interna
            if (mapaAtual) {
                map.removeLayer(mapaAtual);
                mapaAtual = null;
            }
            
            if (svgOverlay) {
                map.removeLayer(svgOverlay);
                svgOverlay = null;
            }
            
            // Limpar marcadores
            marcadores.forEach(m => map.removeLayer(m));
            marcadores = [];
            
            limparRota();
            
            // Desativar modo planta interna
            modoPlantaInterna = false;
            document.getElementById('voltar-mapa-btn').classList.remove('visible');
            
            // Voltar para vis√£o geral
            if (geojsonLayer) {
                map.fitBounds(geojsonLayer.getBounds(), { padding: [50, 50] });
            }
            
            adicionarMensagemBot('üó∫Ô∏è Voltando ao mapa geral da universidade.');
        }

        // ==== CHAT ====
        const chatMessages = document.getElementById('chat-messages');
        const chatForm = document.getElementById('chat-input-form');
        const chatInput = document.getElementById('chat-input');

        function adicionarMensagem(texto, tipo) {
            const div = document.createElement('div');
            div.className = `message ${tipo}`;
            div.textContent = texto;
            chatMessages.appendChild(div);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function adicionarMensagemBot(texto) {
            adicionarMensagem(texto, 'bot');
        }

        function adicionarMensagemUsuario(texto) {
            adicionarMensagem(texto, 'user');
        }

        // Detectar inten√ß√£o de navega√ß√£o na mensagem
        function detectarIntencaoNavegacao(mensagem) {
            const msg = mensagem.toLowerCase();
            
            // Lista de pr√©dios poss√≠veis
            const predios = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'j', 'k', 'm', 'sc', 't'];
            const nomesPredios = {
                'a': 'A', 'b': 'B', 'c': 'C', 'd': 'D', 'e': 'E', 
                'f': 'F', 'g': 'G', 'h': 'H', 'j': 'J', 'k': 'K', 
                'm': 'M', 'sc': 'SC', 't': 'T',
                'building a': 'A', 'building b': 'B', 'building c': 'C',
                'building d': 'D', 'building e': 'E', 'building f': 'F',
                'building g': 'G', 'building h': 'H', 'building j': 'J',
                'building k': 'K', 'building m': 'M', 'building t': 'T',
                'predio a': 'A', 'predio b': 'B', 'predio c': 'C',
                'predio d': 'D', 'predio e': 'E', 'predio f': 'F',
                'predio g': 'G', 'predio h': 'H', 'predio j': 'J',
                'predio k': 'K', 'predio m': 'M', 'predio t': 'T',
                'pr√©dio a': 'A', 'pr√©dio b': 'B', 'pr√©dio c': 'C',
                'student centre': 'SC', 'centro estudantil': 'SC'
            };
            
            let origem = null;
            let destino = null;
            
            // Padr√µes de origem: "estou em/no", "estou na", "estou no predio"
            const padraoOrigem = /(estou|t√¥|to) (em|no|na|no predio|no pr√©dio|na building|no building)\s+([a-z]+)/gi;
            const matchOrigem = msg.match(padraoOrigem);
            if (matchOrigem) {
                for (let key in nomesPredios) {
                    if (msg.includes(key)) {
                        origem = nomesPredios[key];
                        break;
                    }
                }
            }
            
            // Padr√µes de destino: "ir para", "quero ir", "como chegar", "ir ao/√†"
            const padraoDestino = /(ir|chegar|vou|quero ir|como chegar|ir para|ir ao|ir √†|ir no|ir na|para o|para a)\s+(predio|pr√©dio|building)?\s*([a-z]+)/gi;
            const matchDestino = msg.match(padraoDestino);
            if (matchDestino) {
                // Procurar √∫ltimo pr√©dio mencionado (geralmente √© o destino)
                for (let i = predios.length - 1; i >= 0; i--) {
                    const predio = predios[i];
                    if (msg.includes(' ' + predio) || msg.includes(predio + ' ') || 
                        msg.includes('building ' + predio) || msg.includes('predio ' + predio) ||
                        msg.includes('pr√©dio ' + predio)) {
                        destino = predio.toUpperCase();
                        break;
                    }
                }
            }
            
            // Extrair men√ß√µes diretas de letras (ex: "A para M", "de B para H")
            const matchDireto = msg.match(/\b([a-z])\s+(para|ate|at√©)\s+([a-z])\b/i);
            if (matchDireto) {
                origem = matchDireto[1].toUpperCase();
                destino = matchDireto[3].toUpperCase();
            }
            
            return { origem, destino };
        }

        // Enviar mensagem ao chatbot
        chatForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const mensagem = chatInput.value.trim();
            
            if (!mensagem) return;

            adicionarMensagemUsuario(mensagem);
            chatInput.value = '';

            try {
                const response = await fetch(`${API_URL}/api/chat`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ mensagem })
                });

                const data = await response.json();
                adicionarMensagemBot(data.resposta);

                // Se o chatbot identificou origem e destino, calcular rota
                if (data.origem && data.destino) {
                    document.getElementById('predio-origem').value = data.origem;
                    document.getElementById('predio-destino').value = data.destino;
                    
                    // Calcular rota automaticamente
                    setTimeout(() => calcularRotaPredios(), 500);
                }

            } catch (error) {
                console.error('Erro ao enviar mensagem:', error);
                adicionarMensagemBot('Desculpe, ocorreu um erro ao processar sua mensagem.');
            }
        });

        // Inicializar aplica√ß√£o
        carregarGeoJSON();  // Carrega GeoJSON primeiro
        // carregarPredios(); // Fun√ß√£o antiga desabilitada
        carregarPrediosDisponiveis();  // Carregar pr√©dios para navega√ß√£o
        
        // ==================== NAVEGA√á√ÉO ENTRE PR√âDIOS ====================
        
        let linhaRotaPredios = null;
        let marcadoresRotaPredios = [];
        
        // Carregar lista de pr√©dios dispon√≠veis
        async function carregarPrediosDisponiveis() {
            console.log('üîç Iniciando carregamento de pr√©dios dispon√≠veis...');
            console.log('üåê API_URL:', API_URL);
            
            try {
                const url = `${API_URL}/api/predios-disponiveis`;
                console.log('üì° Fazendo fetch para:', url);
                
                const response = await fetch(url);
                console.log('üì® Response status:', response.status);
                console.log('üì® Response ok:', response.ok);
                
                const data = await response.json();
                console.log('üì¶ Dados recebidos:', data);
                
                const selectOrigem = document.getElementById('predio-origem');
                const selectDestino = document.getElementById('predio-destino');
                
                console.log('üéØ Elementos encontrados:', {
                    origem: selectOrigem ? 'SIM' : 'N√ÉO',
                    destino: selectDestino ? 'SIM' : 'N√ÉO'
                });
                
                if (!selectOrigem || !selectDestino) {
                    console.error('‚ùå Elementos select n√£o encontrados!');
                    return;
                }
                
                // Limpar op√ß√µes atuais
                selectOrigem.innerHTML = '<option value="">Selecione o pr√©dio</option>';
                selectDestino.innerHTML = '<option value="">Selecione o pr√©dio</option>';
                
                // Adicionar pr√©dios
                data.predios.forEach(predio => {
                    const optionOrigem = document.createElement('option');
                    optionOrigem.value = predio.ref;
                    optionOrigem.textContent = `${predio.ref} - ${predio.nome}`;
                    selectOrigem.appendChild(optionOrigem);
                    
                    const optionDestino = document.createElement('option');
                    optionDestino.value = predio.ref;
                    optionDestino.textContent = `${predio.ref} - ${predio.nome}`;
                    selectDestino.appendChild(optionDestino);
                });
                
                console.log(`‚úÖ ${data.total} pr√©dios carregados para navega√ß√£o`);
                console.log(`üìù Total de op√ß√µes em origem: ${selectOrigem.options.length}`);
                console.log(`üìù Total de op√ß√µes em destino: ${selectDestino.options.length}`);
            } catch (error) {
                console.error('‚ùå Erro ao carregar pr√©dios:', error);
                console.error('Stack trace:', error.stack);
            }
        }
        
        // Calcular rota entre pr√©dios
        async function calcularRotaPredios() {
            const origem = document.getElementById('predio-origem').value;
            const destino = document.getElementById('predio-destino').value;
            
            if (!origem || !destino) {
                alert('Por favor, selecione origem e destino');
                return;
            }
            
            if (origem === destino) {
                alert('Origem e destino s√£o o mesmo pr√©dio!');
                return;
            }
            
            try {
                limparRotaPredios();
                
                const response = await fetch(`${API_URL}/api/rota-predios`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({origem, destino})
                });
                
                if (!response.ok) throw new Error('Erro ao calcular rota');
                
                const data = await response.json();
                console.log('Rota calculada:', data);
                
                desenharRotaPredios(data.rota);
                mostrarInfoRota(data);
                
                if (data.rota.coordenadas_rota && data.rota.coordenadas_rota.length > 0) {
                    const coords = data.rota.coordenadas_rota.map(c => [c[1], c[0]]);
                    map.fitBounds(L.latLngBounds(coords), { padding: [50, 50] });
                }
                
            } catch (error) {
                console.error('Erro:', error);
                alert(`Erro: ${error.message}`);
            }
        }
        
        // Encontrar ponto mais pr√≥ximo no pol√≠gono do pr√©dio
        function encontrarPontoMaisProximo(coords, pontoAlvo) {
            // coords √© um array de [lng, lat]
            // pontoAlvo √© [lat, lng] (formato Leaflet)
            let menorDistancia = Infinity;
            let pontoMaisProximo = null;
            
            coords.forEach(coord => {
                const latLng = [coord[1], coord[0]]; // Converter [lng, lat] para [lat, lng]
                const distancia = Math.sqrt(
                    Math.pow(latLng[0] - pontoAlvo[0], 2) + 
                    Math.pow(latLng[1] - pontoAlvo[1], 2)
                );
                
                if (distancia < menorDistancia) {
                    menorDistancia = distancia;
                    pontoMaisProximo = latLng;
                }
            });
            
            return pontoMaisProximo;
        }
        
        // Obter coordenadas do pol√≠gono de um pr√©dio do GeoJSON
        function obterPoligonoPredi(ref) {
            if (!geojsonLayer) return null;
            
            let coordenadas = null;
            geojsonLayer.eachLayer(layer => {
                if (layer.feature && layer.feature.properties.ref === ref) {
                    const geometry = layer.feature.geometry;
                    if (geometry.type === 'Polygon') {
                        coordenadas = geometry.coordinates[0]; // Primeiro anel do pol√≠gono
                    } else if (geometry.type === 'MultiPolygon') {
                        coordenadas = geometry.coordinates[0][0]; // Primeiro pol√≠gono, primeiro anel
                    }
                }
            });
            
            return coordenadas;
        }
        
        // Desenhar rota entre pr√©dios
        function desenharRotaPredios(rota) {
            const caminho = rota.caminho;
            if (!caminho || caminho.length < 2) return;
            
            // Construir pontos da rota simulando caminhada real
            const pontosRota = [];
            
            for (let i = 0; i < caminho.length; i++) {
                const predioAtual = caminho[i];
                const centroAtual = [predioAtual.coords[1], predioAtual.coords[0]];
                const poligonoAtual = obterPoligonoPredi(predioAtual.ref);
                
                if (i === 0) {
                    // PR√âDIO DE ORIGEM
                    if (poligonoAtual && caminho.length > 1) {
                        // Adicionar centro do pr√©dio (voc√™ est√° aqui)
                        pontosRota.push(centroAtual);
                        
                        // Encontrar sa√≠da mais pr√≥xima do pr√≥ximo destino
                        const proximoPredioCentro = [caminho[1].coords[1], caminho[1].coords[0]];
                        const pontoSaida = encontrarPontoMaisProximo(poligonoAtual, proximoPredioCentro);
                        pontosRota.push(pontoSaida);
                    } else {
                        pontosRota.push(centroAtual);
                    }
                    
                } else if (i === caminho.length - 1) {
                    // PR√âDIO DE DESTINO
                    if (poligonoAtual) {
                        // Entrar pela porta mais pr√≥xima do pr√©dio anterior
                        const ultimoPonto = pontosRota[pontosRota.length - 1];
                        const pontoEntrada = encontrarPontoMaisProximo(poligonoAtual, ultimoPonto);
                        pontosRota.push(pontoEntrada);
                        
                        // Ir at√© o centro do pr√©dio (destino final)
                        pontosRota.push(centroAtual);
                    } else {
                        pontosRota.push(centroAtual);
                    }
                    
                } else {
                    // PR√âDIO INTERMEDI√ÅRIO (atravessar)
                    if (poligonoAtual) {
                        // Entrar pela porta mais pr√≥xima do ponto anterior
                        const ultimoPonto = pontosRota[pontosRota.length - 1];
                        const pontoEntrada = encontrarPontoMaisProximo(poligonoAtual, ultimoPonto);
                        pontosRota.push(pontoEntrada);
                        
                        // Atravessar o pr√©dio (passar pelo centro)
                        pontosRota.push(centroAtual);
                        
                        // Sair pela porta mais pr√≥xima do pr√≥ximo pr√©dio
                        const proximoPredioCentro = [caminho[i+1].coords[1], caminho[i+1].coords[0]];
                        const pontoSaida = encontrarPontoMaisProximo(poligonoAtual, proximoPredioCentro);
                        pontosRota.push(pontoSaida);
                    } else {
                        pontosRota.push(centroAtual);
                    }
                }
            }
            
            // Linha removida - mostrar apenas marcadores
            // linhaRotaPredios = L.polyline(pontosRota, {
            //     color: '#FF6B6B',
            //     weight: 4,
            //     opacity: 0.8,
            //     dashArray: '10, 10'
            // }).addTo(map);
            
            // Adicionar marcadores apenas na origem e destino (sem intermedi√°rios)
            caminho.forEach((predio, index) => {
                const isOrigem = index === 0;
                const isDestino = index === caminho.length - 1;
                
                // Mostrar apenas origem e destino
                if (!isOrigem && !isDestino) return;
                
                let cor = isOrigem ? '#28a745' : '#dc3545';
                let icone = isOrigem ? 'üöÄ' : 'üéØ';
                
                const marker = L.marker([predio.coords[1], predio.coords[0]], {
                    icon: L.divIcon({
                        html: `<div style="background: ${cor}; color: white; padding: 8px 12px; border-radius: 20px; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">
                                ${icone} ${predio.ref}
                              </div>`,
                        className: '',
                        iconSize: [60, 40],
                        iconAnchor: [30, 20]
                    })
                }).addTo(map);
                
                marker.bindPopup(`<b>${predio.nome}</b><br>${isOrigem ? 'üöÄ Origem' : 'üéØ Destino'}`);
                marcadoresRotaPredios.push(marker);
            });
        }
        
        // Mostrar informa√ß√µes da rota
        function mostrarInfoRota(data, origem = null, destino = null) {
            // Se n√£o receber origem/destino, pegar dos dropdowns
            if (!origem) origem = document.getElementById('predio-origem').value;
            if (!destino) destino = document.getElementById('predio-destino').value;
            
            // Buscar nomes dos pr√©dios
            const selectOrigem = document.getElementById('predio-origem');
            const selectDestino = document.getElementById('predio-destino');
            
            const nomeOrigem = selectOrigem.options[selectOrigem.selectedIndex]?.text || origem;
            const nomeDestino = selectDestino.options[selectDestino.selectedIndex]?.text || destino;
            
            document.getElementById('rota-origem-destino').textContent = `üöÄ ${nomeOrigem} ‚Üí üéØ ${nomeDestino}`;
            document.getElementById('rota-distancia').textContent = `üìè Dist√¢ncia: ${data.rota.distancia_metros}m`;
            document.getElementById('rota-tempo').textContent = `‚è±Ô∏è Tempo: ${data.tempo_estimado}`;
            document.getElementById('rota-info').classList.add('visible');
        }
        
        // Limpar rota
        function limparRotaPredios() {
            if (linhaRotaPredios) {
                map.removeLayer(linhaRotaPredios);
                linhaRotaPredios = null;
            }
            marcadoresRotaPredios.forEach(m => map.removeLayer(m));
            marcadoresRotaPredios = [];
            document.getElementById('rota-info').classList.remove('visible');
        }
        
        // Event listeners
        // Bot√£o de calcular rota removido - agora usa apenas chatbot
        document.getElementById('limpar-rota-predios').addEventListener('click', limparRotaPredios);
    </script>
</body>
</html>
